{"file_path": "/tmp/verification.pml", "promela": "//**********VARIABLE DECLARATION************//\nint x = 0\nint old_x = x\n\n//**********CWP VARIABLE DECLARATION************//\nbool Start = true\nbool Increment_x = false\nbool End = false\n//**********************************************//\n\ninline updateState() {\n\tbool Increment_x_prime = (x <= 5) && !(x > 5)\n\tbool End_prime = (x > 5) && !(false)\n\tif\n\t\t:: Start && Increment_x_prime\n\t\t:: Increment_x && End_prime\n\t\t:: Increment_x && Increment_x_prime\n\t\t:: End && End_prime\n\t\t:: else -> assert false\n\tfi\n\tStart = false\n\tIncrement_x = Increment_x_prime\n\tEnd = End_prime\n\t// Verification of properties 1 & 2 (verifying that we are always in one state and only one state)\n\tint sumOfActiveStates = Increment_x + End\n\n\tif\n\t\t:: (sumOfActiveStates != 1) -> assert false\n\t\t:: else -> skip\n\tfi\n}\ninline stateLogger(){\n\tprintf(\"Changed Vars: \\n\");\n\tif\n\t\t:: x != old_x ->\n\t\t\tprintf(\"x = %e\\n\", x);\n\t\t\told_x = x\n\t\t:: else -> skip\n\tfi;\n\tif\n\t\t:: Increment_x == true ->\n\t\t\tprintf(\"Current state: Increment_x\\n\");\n\t\t:: else -> skip\n\tfi;\n\tif\n\t\t:: End == true ->\n\t\t\tprintf(\"Current state: End\\n\");\n\t\t:: else -> skip\n\tfi;\n}\n#define hasToken(place) (place != 0)\n\ninline putToken(place) {\n\tassert (place != 1)\n\tplace = 1\n}\n\n#define consumeToken(place) place = 0\n\n\nbit StartEvent_1 = 0\nbit Task_1_FROM_StartEvent_1 = 0\nbit Task_1_FROM_Gateway_1 = 0\nbit Gateway_1_FROM_Task_1 = 0\nbit EndEvent_1_FROM_Gateway_1 = 0\ninline StartEvent_1_BehaviorModel() {\n\tskip\n}\n\ninline Task_1_BehaviorModel() {\n\tx = x + 1\n\tupdateState()\n}\n\ninline EndEvent_1_BehaviorModel() {\n\tskip\n}\n\ninit {\n\trun Process_1()\n}\n\nproctype Process_1() {\n\td_step {\n\t\tprintf(\"ID: Process_1\\n\")\n\t\tstateLogger()\n\t\tpid me = _pid\n\t\tputToken(StartEvent_1)\n\t}\n\tdo\n\t:: atomic { ((hasToken(StartEvent_1))) ->\n\t\tStartEvent_1_BehaviorModel()\n\t\td_step {\n\t\t\tprintf(\"ID: StartEvent_1\\n\")\n\t\t\tstateLogger()\n\t\t\tconsumeToken(StartEvent_1)\n\t\t\tputToken(Task_1_FROM_StartEvent_1)\n\t\t}\n\t}\n\t:: atomic { ((hasToken(Task_1_FROM_StartEvent_1) || hasToken(Task_1_FROM_Gateway_1))) ->\n\t\tTask_1_BehaviorModel()\n\t\td_step {\n\t\t\tprintf(\"ID: Task_1\\n\")\n\t\t\tstateLogger()\n\t\t\tconsumeToken(Task_1_FROM_StartEvent_1)\n\t\t\tconsumeToken(Task_1_FROM_Gateway_1)\n\t\t\tputToken(Gateway_1_FROM_Task_1)\n\t\t}\n\t}\n\t:: atomic { ((hasToken(Gateway_1_FROM_Task_1))) ->\n\t\td_step {\n\t\t\tprintf(\"ID: Gateway_1\\n\")\n\t\t\tstateLogger()\n\t\t\tconsumeToken(Gateway_1_FROM_Task_1)\n\t\t\tif\n\t\t\t:: x > 5 -> putToken(EndEvent_1_FROM_Gateway_1)\n\t\t\t:: x <=5 -> putToken(Task_1_FROM_Gateway_1)\n\t\t\t:: atomic{else -> assert false}\n\t\t\tfi\n\t\t}\n\t}\n\t:: atomic { ((hasToken(EndEvent_1_FROM_Gateway_1))) ->\n\t\tEndEvent_1_BehaviorModel()\n\t\td_step {\n\t\t\tprintf(\"ID: EndEvent_1\\n\")\n\t\t\tstateLogger()\n\t\t\tconsumeToken(EndEvent_1_FROM_Gateway_1)\n\t\t}\n\t\tbreak\n\t}\n\tod\n}\n", "spin_cli_args": ["-run", "-noclaim"], "spin_report": "\n(Spin Version 6.5.2 -- 6 December 2019)\n\t+ Partial Order Reduction\n\nFull statespace search for:\n\tnever claim         \t- (not selected)\n\tassertion violations\t+\n\tcycle checks       \t- (disabled by -DSAFETY)\n\tinvalid end states\t+\n\nState-vector 32 byte, depth reached 65, errors: 0\n       19 states, stored\n        0 states, matched\n       19 transitions (= stored+matched)\n       47 atomic steps\nhash conflicts:         0 (resolved)\n\nStats on memory usage (in Megabytes):\n    0.001\tequivalent memory usage for states (stored*(State-vector + overhead))\n    0.284\tactual memory usage for states\n  128.000\tmemory used for hash table (-w24)\n    0.534\tmemory used for DFS stack (-m10000)\n  128.730\ttotal actual memory usage\n\n\nunreached in init\n\t(0 of 2 states)\nunreached in proctype Process_1\n\tverification.pml:19, state 68, \"assert(0)\"\n\t(1 of 183 states)\n\npan: elapsed time 0 seconds\n"}
